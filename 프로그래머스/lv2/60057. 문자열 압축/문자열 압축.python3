def solution(s):
    '''
    1. 1개부터 s길이의 절반의 갯수를 단계로 순환
    2. 단계만큼 잘라가면서 직전의 문자열과 비교하여 반복될경우 반복수를 올려나가고
    3. 반복되지 않는 다른 문자를 만나면 반복수와 해당 문자를 출력
    4. 반복수를 초기화하고 이전단계 반복되지 않는 비교문자열부터 새로 비교해 나간다. 
    5. 한 사이클이 끝나면 s의 길이와 압축된 길이를 비교해서 작은 값을 answer에 갱신하고
    6. 모든 사이클이 끝나면 최저값이 출력된다.   
    '''
    answer = len(s)
    # 1개 단계부터 압축 단위를 늘려가며 확인
    for 단계 in range(1, len(s) // 2 + 1) :
        압축 = ""
        비교문자열 = s[0:단계] # 앞에서부터 step만큼의 문자열 추출
        반복수 = 1
        
        #단위(단계) 크기만큼 증가시키며 이전 문자열과 비교
        for j in range(단계, len(s), 단계) :
            #이전 상태와 동일하다면 압축 횟수(반복수) 증가
            if 비교문자열 == s[j:j + 단계] :
                반복수 += 1
            # 다른 문자열이 나왔다면
            else:
                압축 += str(반복수) + 비교문자열 if 반복수 >= 2 else 비교문자열
                비교문자열 = s[j:j + 단계] # 다시 상태 초기화
                반복수 = 1
                
        # 남아 있는 문자열에 대해서 처리
        압축 += str(반복수) + 비교문자열 if 반복수 >= 2 else 비교문자열
        # 만들어지는 압축 문자열이 가장 짧은 것이 정답
        answer = min(answer, len(압축))
    
    return answer

s = "aabbaccc"
solution(s)